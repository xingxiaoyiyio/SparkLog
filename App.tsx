import React, { useState, useRef, useEffect } from 'react';
import { InputArea } from './components/InputArea';
import { ChatMessage } from './components/ChatMessage';
import { DailySummary } from './components/DailySummary';
import { HistoryView } from './components/HistoryView';
import { geminiService } from './services/geminiService';
import { Message, Role, ChatStatus, DailySummaryData } from './types';
import { Sparkles, ScrollText, History, Trash2, Eraser } from 'lucide-react';

// Initial message in Chinese
const INITIAL_MESSAGE: Message = {
  id: 'init-1',
  role: Role.MODEL,
  text: "å˜¿ï¼ğŸ‘‹ ä»Šå¤©è¿‡å¾—æ€ä¹ˆæ ·ï¼Ÿç”©ä¸ªé“¾æ¥ã€å‘å¼ ç…§ç‰‡ï¼Œæˆ–è€…å•çº¯åæ§½ä¸€ä¸‹å·¥ä½œã€‚æˆ‘å‡†å¤‡å¥½å•¦ï¼",
  timestamp: new Date()
};

// Interface for History Item
interface HistoryItem {
    id: number;
    data: DailySummaryData;
}

export default function App() {
  const [messages, setMessages] = useState<Message[]>([INITIAL_MESSAGE]);
  const [status, setStatus] = useState<ChatStatus>('idle');
  const [showSummary, setShowSummary] = useState(false);
  const [showHistory, setShowHistory] = useState(false);
  const [summaryData, setSummaryData] = useState<DailySummaryData | null>(null);
  const [history, setHistory] = useState<HistoryItem[]>([]);
  
  // Track if we have already auto-generated a summary for today to prevent loops
  const [autoGeneratedDate, setAutoGeneratedDate] = useState<string | null>(null);
  
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages, status]);

  // Load history from local storage on mount
  useEffect(() => {
      const savedHistory = localStorage.getItem('sparklog_history');
      if (savedHistory) {
          try {
              const parsed = JSON.parse(savedHistory);
              setHistory(parsed);
          } catch (e) {
              console.error("Failed to parse history", e);
          }
      }
  }, []);

  // Time-based Automation Logic (0:00 Greeting, 23:59 Summary)
  useEffect(() => {
    const checkTimeEvents = () => {
        const now = new Date();
        const currentHour = now.getHours();
        const currentMinute = now.getMinutes();
        const todayStr = now.toDateString();

        // 1. New Day Greeting (0:00)
        const lastGreetedDate = localStorage.getItem('lastGreetedDate');
        if (currentHour === 0 && currentMinute === 0 && lastGreetedDate !== todayStr) {
            const greetingMsg: Message = {
                id: Date.now().toString(),
                role: Role.MODEL,
                text: "åˆæ˜¯æ–°çš„ä¸€å¤©ï¼â˜€ï¸ æ˜¨å¤©è¿‡å¾—è¿˜å¥½å—ï¼Ÿä»Šå¤©æœ‰ä»€ä¹ˆæ–°è®¡åˆ’ï¼Œæˆ–è€…åªæ˜¯æƒ³è®°å½•ç‚¹ä»€ä¹ˆï¼Ÿ",
                timestamp: new Date()
            };
            setMessages(prev => [...prev, greetingMsg]);
            localStorage.setItem('lastGreetedDate', todayStr);
            // Reset auto-gen flag for the new day
            setAutoGeneratedDate(null);
        }

        // 2. Auto Summary (23:59)
        // Check if it's 23:59, we haven't generated yet today, and there are records
        if (currentHour === 23 && currentMinute === 59 && autoGeneratedDate !== todayStr) {
             // We need to check if we should generate. 
             // We can't access 'messages' state directly inside this closure accurately if not in dependency array,
             // but adding messages to dependency would re-run interval too often.
             // We will trigger a state check via a function.
             attemptAutoSummary(todayStr);
        }
    };

    const attemptAutoSummary = (todayStr: string) => {
        setMessages(currentMessages => {
            // Filter logs for today
            const startOfDay = new Date();
            startOfDay.setHours(0, 0, 0, 0);
            const userLogsToday = currentMessages.filter(m => 
                m.role === Role.USER && 
                new Date(m.timestamp) >= startOfDay
            );

            // If we have logs and haven't generated yet
            if (userLogsToday.length > 0) {
                 // Trigger summary generation logic
                 // Since we are in a state update callback, we need to be careful. 
                 // We'll set a flag or call the function outside.
                 // Actually, calling handleGenerateSummary from here is tricky due to async/state.
                 // Let's use a timeout to break out of the state updater
                 setTimeout(() => {
                    // Double check state inside the timeout (handled by handleGenerateSummary's own checks)
                     handleGenerateSummary(false, true); 
                 }, 0);
                 
                 // Mark as done for today immediately to prevent double trigger
                 setAutoGeneratedDate(todayStr);
            }
            return currentMessages;
        });
    };

    const intervalId = setInterval(checkTimeEvents, 60000); // Check every minute
    return () => clearInterval(intervalId);
  }, [autoGeneratedDate]);


  const saveToHistory = (data: DailySummaryData) => {
      // Avoid duplicates for the same date/content if triggered multiple times quickly
      const isDuplicate = history.some(h => h.data.date === data.date && JSON.stringify(h.data.highlight) === JSON.stringify(data.highlight));
      if (isDuplicate) return;

      const newItem: HistoryItem = { id: Date.now(), data };
      const newHistory = [...history, newItem];
      setHistory(newHistory);
      localStorage.setItem('sparklog_history', JSON.stringify(newHistory));
  };

  const handleDeleteHistory = (id: number) => {
      const newHistory = history.filter(item => item.id !== id);
      setHistory(newHistory);
      localStorage.setItem('sparklog_history', JSON.stringify(newHistory));
  };

  const handleDeleteMessage = (id: string) => {
      setMessages(prev => prev.filter(msg => msg.id !== id));
  };

  const handleClearChat = () => {
      if (window.confirm("ç¡®å®šè¦æ¸…ç©ºå½“å‰çš„èŠå¤©è®°å½•å—ï¼Ÿ(å†å²æ—¥è®°ä¸ä¼šè¢«åˆ é™¤)")) {
          setMessages([INITIAL_MESSAGE]);
          setStatus('idle');
      }
  };

  const handleSendMessage = async (text: string, imageBase64?: string) => {
    // 1. Add user message
    const userMsg: Message = {
      id: Date.now().toString(),
      role: Role.USER,
      text,
      image: imageBase64,
      timestamp: new Date()
    };
    setMessages(prev => [...prev, userMsg]);
    setStatus('thinking');

    try {
      // 2. Check triggers for Summary
      if (text.toLowerCase().includes("wrap up") || text.includes("æ—¥ç»“") || text.includes("ä»Šæ—¥æ€»ç»“")) {
          // Pass true to indicate this is a user triggered summary via text
          await handleGenerateSummary(true);
          return;
      }

      // 3. Normal Chat Interaction
      const response = await geminiService.sendMessage(text, imageBase64);
      
      const botMsg: Message = {
        id: (Date.now() + 1).toString(),
        role: Role.MODEL,
        text: response.text,
        timestamp: new Date(),
        groundingSources: response.sources
      };
      setMessages(prev => [...prev, botMsg]);
      setStatus('idle');

    } catch (error) {
      console.error(error);
      setStatus('idle');
    }
  };

  const handleGenerateSummary = async (isTextTrigger = false, isAutoTrigger = false) => {
    // Get start and end of today
    const now = new Date();
    const startOfDay = new Date(now.setHours(0, 0, 0, 0));
    const endOfDay = new Date(now.setHours(23, 59, 59, 999));

    // Filter messages STRICTLY for today (00:00 - 23:59)
    const userMessages = messages.filter(m => {
        const mDate = new Date(m.timestamp);
        return m.role === Role.USER && mDate >= startOfDay && mDate <= endOfDay;
    });
    
    // If no user messages today
    if (userMessages.length === 0) {
        if (!isAutoTrigger) {
            const noRecordMsg = {
                id: Date.now().toString(),
                role: Role.MODEL,
                text: "è¿˜æ²¡æœ‰è®°å½•ä»»ä½•ç¢ç‰‡å‘¢ï¼å…ˆèŠç‚¹ä»€ä¹ˆå§ï¼Œæ¯”å¦‚å‘å¼ ç…§ç‰‡æˆ–è€…åˆ†äº«ä¸ªé“¾æ¥ï¼ŸğŸ¤”",
                timestamp: new Date()
            };
            setMessages(prev => [...prev, noRecordMsg]);
        }
        setStatus('idle');
        return;
    }

    setStatus('generating_summary');
    
    if (!isTextTrigger && !isAutoTrigger) {
        setMessages(prev => [...prev, {
            id: Date.now().toString(),
            role: Role.MODEL,
            text: "æ”¶åˆ°ï¼æ­£åœ¨æŠŠæˆ‘ä»¬ä»Šå¤©çš„ç¢ç‰‡ç»‡æˆæ—¥è®°... ğŸ§µâœ¨",
            timestamp: new Date()
        }]);
    }

    try {
        // 1. Generate JSON Summary from Gemini
        const aiData = await geminiService.generateDailySummary();

        // 2. Inject Raw User Logs locally (Filtering out the trigger words)
        const rawLogs = userMessages
            .filter(m => !m.text.includes("æ—¥ç»“") && !m.text.includes("ä»Šæ—¥æ€»ç»“"))
            .map(m => m.text);

        const finalData: DailySummaryData = {
            ...aiData,
            rawLog: rawLogs
        };

        setSummaryData(finalData);
        if (!isAutoTrigger) {
            setShowSummary(true);
        }
        
        // 3. Auto Save to History
        saveToHistory(finalData);
        
        // Mark as generated for today to satisfy the 23:59 check logic if manually triggered
        setAutoGeneratedDate(new Date().toDateString());

        setStatus('idle');
        
        if (isAutoTrigger) {
             // For auto trigger, we might just want to save it (done above) and maybe notify user next time or just append a message
             setMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: Role.MODEL,
                text: "âœ¨ è¿™ä¸€å¤©ç»“æŸå•¦ï¼Œæˆ‘å·²ç»è‡ªåŠ¨å¸®ä½ ç”Ÿæˆäº†ä»Šæ—¥æ—¥ç»“ï¼Œå¿«å»å†å²è®°å½•é‡Œçœ‹çœ‹å§ï¼æ™šå®‰ ğŸŒ™",
                timestamp: new Date()
            }]);
        }

    } catch (e) {
        console.error("Summary failed", e);
        setStatus('idle');
        if (!isAutoTrigger) {
            setMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: Role.MODEL,
                text: "å“å‘€ï¼Œå†™æ—¥è®°çš„æ—¶å€™è¢«ç”µçº¿ç»Šå€’äº†ã€‚èƒ½å†è¯•ä¸€æ¬¡å—ï¼ŸğŸ˜…",
                timestamp: new Date()
            }]);
        }
    }
  };

  const handleHistorySelect = (data: DailySummaryData) => {
      setSummaryData(data);
      setShowHistory(false);
      setShowSummary(true);
  };

  return (
    <div className="flex flex-col h-screen max-w-2xl mx-auto bg-transparent relative border-x border-white/20 shadow-2xl">
      {/* Header */}
      <header className="bg-white/60 backdrop-blur-xl sticky top-0 z-10 px-6 py-4 flex items-center justify-between border-b border-white/40">
        <div className="flex items-center gap-3">
          <div className="bg-gradient-aurora text-white p-2.5 rounded-xl shadow-lg shadow-aurora-purple/20">
            <Sparkles size={20} />
          </div>
          <div>
            <h1 className="font-bold text-slate-800 text-lg leading-tight tracking-tight font-sans">
                <span className="text-transparent bg-clip-text bg-gradient-to-r from-aurora-purple to-aurora-green">SparkLog</span>
            </h1>
            <p className="text-[10px] text-slate-500 font-mono uppercase tracking-wider">AI Fragment Diary</p>
          </div>
        </div>
        <div className="flex gap-2">
            <button 
                onClick={handleClearChat}
                disabled={status !== 'idle' || messages.length <= 1}
                className={`p-2.5 rounded-xl transition-all border border-transparent ${
                    status !== 'idle' || messages.length <= 1 
                    ? 'text-slate-300 cursor-not-allowed' 
                    : 'text-slate-400 hover:text-red-500 hover:bg-white hover:border-red-100 hover:shadow-sm'
                }`}
                title="æ¸…ç©ºå½“å‰å¯¹è¯"
            >
                <Eraser size={20} />
            </button>
            <div className="w-px h-8 bg-slate-200 mx-1 self-center"></div>
            <button 
                onClick={() => handleGenerateSummary(false)}
                disabled={status !== 'idle'}
                className={`p-2.5 rounded-xl transition-all border border-transparent ${
                    status !== 'idle' ? 'text-slate-300 cursor-not-allowed' : 'text-slate-500 hover:text-aurora-purple hover:bg-white hover:border-aurora-purple/20 hover:shadow-sm'
                }`}
                title="ç”Ÿæˆä»Šæ—¥æ—¥ç»“"
            >
                <ScrollText size={20} />
            </button>
            <button 
                onClick={() => setShowHistory(true)}
                className="p-2.5 text-slate-500 hover:text-aurora-green hover:bg-white hover:border-aurora-green/20 border border-transparent rounded-xl transition-all hover:shadow-sm"
                title="å†å²æ—¥è®°"
            >
                <History size={20} />
            </button>
        </div>
      </header>

      {/* Chat Area */}
      <main className="flex-1 overflow-y-auto px-4 py-6 scroll-smooth space-y-2">
        {messages.map(msg => (
          <ChatMessage 
            key={msg.id} 
            message={msg} 
            onDelete={handleDeleteMessage}
          />
        ))}
        
        {status === 'thinking' && (
           <div className="flex items-center gap-2 text-slate-400 text-xs ml-5 mb-4 animate-pulse font-mono bg-white/40 inline-block px-3 py-1 rounded-full border border-white/50">
              <Sparkles size={12} className="text-aurora-purple" />
              <span>Thinking...</span>
           </div>
        )}
        
        {status === 'generating_summary' && (
           <div className="flex items-center gap-2 text-aurora-green text-xs ml-5 mb-4 animate-pulse font-mono bg-white/40 inline-block px-3 py-1 rounded-full border border-white/50">
              <ScrollText size={12} />
              <span>Generating Summary...</span>
           </div>
        )}

        <div ref={messagesEndRef} />
      </main>

      {/* Input */}
      <InputArea onSendMessage={handleSendMessage} isLoading={status !== 'idle'} />

      {/* Summary Modal */}
      {showSummary && summaryData && (
        <DailySummary 
          data={summaryData} 
          onClose={() => setShowSummary(false)} 
        />
      )}

      {/* History Modal */}
      {showHistory && (
          <HistoryView 
            history={history}
            onSelect={handleHistorySelect}
            onDelete={handleDeleteHistory}
            onClose={() => setShowHistory(false)}
          />
      )}
    </div>
  );
}
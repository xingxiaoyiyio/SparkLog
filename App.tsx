import React, { useState, useRef, useEffect } from 'react';
import { InputArea } from './components/InputArea';
import { ChatMessage } from './components/ChatMessage';
import { DailySummary } from './components/DailySummary';
import { HistoryView } from './components/HistoryView';
import { geminiService } from './services/geminiService';
import { Message, Role, ChatStatus, DailySummaryData } from './types';
import { Sparkles, ScrollText, History, Eraser } from 'lucide-react';

// Initial message in Chinese
const INITIAL_MESSAGE: Message = {
  id: 'init-1',
  role: Role.MODEL,
  text: "å˜¿ï¼ğŸ‘‹ ä»Šå¤©è¿‡å¾—æ€ä¹ˆæ ·ï¼Ÿéšæ—¶è·Ÿæˆ‘è®°ä¸ªæµæ°´è´¦ï¼Œæˆ–è€…å•çº¯åæ§½ä¸€ä¸‹ã€‚æˆ‘å‡†å¤‡å¥½å•¦ï¼",
  timestamp: new Date()
};

// Interface for History Item
interface HistoryItem {
    id: number;
    data: DailySummaryData;
}

export default function App() {
  // 1. Initialize messages from LocalStorage (Persistence)
  const [messages, setMessages] = useState<Message[]>(() => {
      try {
          const saved = localStorage.getItem('sparklog_current_chat');
          if (saved) {
              const parsed = JSON.parse(saved);
              // Rehydrate Date objects from strings
              return parsed.map((m: any) => ({
                  ...m,
                  timestamp: new Date(m.timestamp)
              }));
          }
      } catch (e) {
          console.error("Failed to load chat persistence", e);
      }
      return [INITIAL_MESSAGE];
  });

  const [status, setStatus] = useState<ChatStatus>('idle');
  const [showSummary, setShowSummary] = useState(false);
  const [showHistory, setShowHistory] = useState(false);
  const [summaryData, setSummaryData] = useState<DailySummaryData | null>(null);
  const [history, setHistory] = useState<HistoryItem[]>([]);
  
  // Track if we have already auto-generated a summary for today to prevent loops
  const [autoGeneratedDate, setAutoGeneratedDate] = useState<string | null>(null);
  
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages, status]);

  // 2. Persist messages to LocalStorage whenever they change
  useEffect(() => {
      localStorage.setItem('sparklog_current_chat', JSON.stringify(messages));
  }, [messages]);

  // Load history from local storage on mount
  useEffect(() => {
      const savedHistory = localStorage.getItem('sparklog_history');
      if (savedHistory) {
          try {
              const parsed = JSON.parse(savedHistory);
              setHistory(parsed);
          } catch (e) {
              console.error("Failed to parse history", e);
          }
      }
      
      // Initialize chat date tracker if missing
      if (!localStorage.getItem('sparklog_chat_date')) {
          localStorage.setItem('sparklog_chat_date', new Date().toDateString());
      }
  }, []);

  // Time-based Automation Logic (0:00 Reset/Greeting, 23:59 Summary)
  useEffect(() => {
    const checkTimeEvents = () => {
        const now = new Date();
        const currentHour = now.getHours();
        const currentMinute = now.getMinutes();
        const todayStr = now.toDateString();
        const storedDate = localStorage.getItem('sparklog_chat_date');

        // 1. New Day Logic (Date Rollover)
        // If the stored date is different from today, it means it's a new day (0:00 or app opened next day)
        if (storedDate && storedDate !== todayStr) {
            console.log("New day detected. Resetting chat...");
            
            // a. Retrieve previous history to find To-Dos
            let pendingTodos: string[] = [];
            const savedHistoryStr = localStorage.getItem('sparklog_history');
            if (savedHistoryStr) {
                try {
                    const parsedHistory: HistoryItem[] = JSON.parse(savedHistoryStr);
                    if (parsedHistory.length > 0) {
                        // Get the most recent entry (yesterday's summary)
                        const lastEntry = parsedHistory[parsedHistory.length - 1];
                        if (lastEntry.data.actionItems && lastEntry.data.actionItems.length > 0) {
                            pendingTodos = lastEntry.data.actionItems;
                        }
                    }
                } catch (e) { console.error(e); }
            }

            // b. Generate New Greeting
            let greetingText = "åˆæ˜¯æ–°çš„ä¸€å¤©ï¼â˜€ï¸ æ˜¨å¤©è¿‡å¾—è¿˜å¥½å—ï¼Ÿ";
            if (pendingTodos.length > 0) {
                greetingText += "\n\nğŸ“‹ æ˜¨å¤©çš„å¾…åŠäº‹é¡¹åˆ«å¿˜å•¦ï¼š\n" + pendingTodos.map(t => `- ${t}`).join('\n');
                greetingText += "\n\nä»Šå¤©æœ‰ä»€ä¹ˆæ–°è®¡åˆ’å—ï¼Ÿ";
            } else {
                greetingText += " ä»Šå¤©æœ‰ä»€ä¹ˆæ–°è®¡åˆ’ï¼Œæˆ–è€…åªæ˜¯æƒ³è®°å½•ç‚¹ä»€ä¹ˆï¼Ÿ";
            }

            const newGreetingMsg: Message = {
                id: Date.now().toString(),
                role: Role.MODEL,
                text: greetingText,
                timestamp: new Date()
            };

            // c. Delete previous day's conversations (Reset State)
            setMessages([newGreetingMsg]);
            
            // d. Update stored date
            localStorage.setItem('sparklog_chat_date', todayStr);
            localStorage.setItem('lastGreetedDate', todayStr); // Sync legacy flag
            setAutoGeneratedDate(null); // Reset auto-gen flag
        }

        // 2. Auto Summary (23:59)
        // Check if it's 23:59, we haven't generated yet today, and there are records
        if (currentHour === 23 && currentMinute === 59 && autoGeneratedDate !== todayStr) {
             attemptAutoSummary(todayStr);
        }
    };

    const attemptAutoSummary = (todayStr: string) => {
        setMessages(currentMessages => {
            // Filter logs for today
            const startOfDay = new Date();
            startOfDay.setHours(0, 0, 0, 0);
            const userLogsToday = currentMessages.filter(m => 
                m.role === Role.USER && 
                new Date(m.timestamp) >= startOfDay
            );

            // If we have logs and haven't generated yet
            if (userLogsToday.length > 0) {
                 setTimeout(() => {
                     handleGenerateSummary(false, true); 
                 }, 0);
                 
                 // Mark as done for today immediately to prevent double trigger
                 setAutoGeneratedDate(todayStr);
            }
            return currentMessages;
        });
    };

    const intervalId = setInterval(checkTimeEvents, 10000); // Check every 10 seconds for more precision
    
    // Run check immediately on mount to handle "opened next day" scenario
    checkTimeEvents();

    return () => clearInterval(intervalId);
  }, [autoGeneratedDate]); // Dependency on autoGen flag


  const saveToHistory = (data: DailySummaryData) => {
      // Avoid duplicates for the same date/content if triggered multiple times quickly
      const isDuplicate = history.some(h => h.data.date === data.date && JSON.stringify(h.data.highlight) === JSON.stringify(data.highlight));
      if (isDuplicate) return;

      const newItem: HistoryItem = { id: Date.now(), data };
      const newHistory = [...history, newItem];
      setHistory(newHistory);
      localStorage.setItem('sparklog_history', JSON.stringify(newHistory));
  };

  const handleDeleteHistory = (id: number) => {
      const newHistory = history.filter(item => item.id !== id);
      setHistory(newHistory);
      localStorage.setItem('sparklog_history', JSON.stringify(newHistory));
  };

  const handleDeleteMessage = (id: string) => {
      setMessages(prev => prev.filter(msg => msg.id !== id));
  };

  const handleClearChat = () => {
      if (window.confirm("ç¡®å®šè¦æ¸…ç©ºå½“å‰çš„èŠå¤©è®°å½•å—ï¼Ÿ(å†å²æ—¥è®°ä¸ä¼šè¢«åˆ é™¤)")) {
          setMessages([INITIAL_MESSAGE]);
          setStatus('idle');
          // Update the date tracker to today so we don't trigger "New Day" logic immediately again if date was stale
          localStorage.setItem('sparklog_chat_date', new Date().toDateString());
      }
  };

  const handleSendMessage = async (text: string, imageBase64?: string) => {
    // 1. Add user message
    const userMsg: Message = {
      id: Date.now().toString(),
      role: Role.USER,
      text,
      image: imageBase64,
      timestamp: new Date()
    };
    setMessages(prev => [...prev, userMsg]);
    setStatus('thinking');

    try {
      // 2. Check triggers for Summary
      if (text.toLowerCase().includes("wrap up") || text.includes("æ—¥ç»“") || text.includes("ä»Šæ—¥æ€»ç»“")) {
          // Pass true to indicate this is a user triggered summary via text
          await handleGenerateSummary(true);
          return;
      }

      // 3. Normal Chat Interaction
      const response = await geminiService.sendMessage(text, imageBase64);
      
      const botMsg: Message = {
        id: (Date.now() + 1).toString(),
        role: Role.MODEL,
        text: response.text,
        timestamp: new Date(),
        groundingSources: response.sources
      };
      setMessages(prev => [...prev, botMsg]);
      setStatus('idle');

    } catch (error) {
      console.error(error);
      setStatus('idle');
    }
  };

  const handleGenerateSummary = async (isTextTrigger = false, isAutoTrigger = false) => {
    // Get start and end of today
    const now = new Date();
    const startOfDay = new Date(now.setHours(0, 0, 0, 0));
    const endOfDay = new Date(now.setHours(23, 59, 59, 999));

    // Filter messages STRICTLY for today (00:00 - 23:59)
    // We capture BOTH user and model messages to give context to the summary
    const todayMessages = messages.filter(m => {
        const mDate = new Date(m.timestamp);
        return mDate >= startOfDay && mDate <= endOfDay;
    });

    // Check if there are any user messages today
    const hasUserContent = todayMessages.some(m => m.role === Role.USER);
    
    // If no user messages today
    if (!hasUserContent) {
        if (!isAutoTrigger) {
            const noRecordMsg = {
                id: Date.now().toString(),
                role: Role.MODEL,
                text: "è¿˜æ²¡æœ‰è®°å½•ä»»ä½•ç¢ç‰‡å‘¢ï¼å…ˆèŠç‚¹ä»€ä¹ˆå§ï¼Œæ¯”å¦‚å‘å¼ ç…§ç‰‡æˆ–è€…åˆ†äº«ä¸ªé“¾æ¥ï¼ŸğŸ¤”",
                timestamp: new Date()
            };
            setMessages(prev => [...prev, noRecordMsg]);
        }
        setStatus('idle');
        return;
    }

    setStatus('generating_summary');
    
    if (!isTextTrigger && !isAutoTrigger) {
        setMessages(prev => [...prev, {
            id: Date.now().toString(),
            role: Role.MODEL,
            text: "æ”¶åˆ°ï¼æ­£åœ¨æŠŠæˆ‘ä»¬ä»Šå¤©çš„ç¢ç‰‡ç»‡æˆæ—¥è®°... ğŸ§µâœ¨",
            timestamp: new Date()
        }]);
    }

    try {
        // 1. Generate JSON Summary from Gemini - PASSING THE FULL CONTEXT
        const aiData = await geminiService.generateDailySummary(todayMessages);

        // 2. Inject Raw User Logs locally (Filtering out the trigger words)
        const rawLogs = todayMessages
            .filter(m => m.role === Role.USER && !m.text.includes("æ—¥ç»“") && !m.text.includes("ä»Šæ—¥æ€»ç»“"))
            .map(m => m.text);

        const finalData: DailySummaryData = {
            ...aiData,
            rawLog: rawLogs
        };

        setSummaryData(finalData);
        if (!isAutoTrigger) {
            setShowSummary(true);
        }
        
        // 3. Auto Save to History
        saveToHistory(finalData);
        
        // Mark as generated for today to satisfy the 23:59 check logic if manually triggered
        setAutoGeneratedDate(new Date().toDateString());

        setStatus('idle');
        
        if (isAutoTrigger) {
             setMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: Role.MODEL,
                text: "âœ¨ è¿™ä¸€å¤©ç»“æŸå•¦ï¼Œæˆ‘å·²ç»è‡ªåŠ¨å¸®ä½ ç”Ÿæˆäº†ä»Šæ—¥æ—¥ç»“ï¼Œå¿«å»å†å²è®°å½•é‡Œçœ‹çœ‹å§ï¼æ™šå®‰ ğŸŒ™",
                timestamp: new Date()
            }]);
        }

    } catch (e) {
        console.error("Summary failed", e);
        setStatus('idle');
        if (!isAutoTrigger) {
            setMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: Role.MODEL,
                text: "å“å‘€ï¼Œå†™æ—¥è®°çš„æ—¶å€™è¢«ç”µçº¿ç»Šå€’äº†ã€‚èƒ½å†è¯•ä¸€æ¬¡å—ï¼ŸğŸ˜…",
                timestamp: new Date()
            }]);
        }
    }
  };

  const handleHistorySelect = (data: DailySummaryData) => {
      setSummaryData(data);
      setShowHistory(false);
      setShowSummary(true);
  };

  return (
    <div className="flex flex-col h-screen w-full bg-transparent relative border-x border-white/20 shadow-2xl">
      {/* Header */}
      <header className="bg-white/60 backdrop-blur-xl sticky top-0 z-10 border-b border-white/40">
        <div className="max-w-2xl mx-auto w-full px-6 py-4 flex items-center justify-between">
            <div className="flex items-center gap-3">
            <div className="bg-gradient-aurora text-white p-2.5 rounded-xl shadow-lg shadow-aurora-purple/20">
                <Sparkles size={20} />
            </div>
            <div>
                <h1 className="font-bold text-slate-800 text-lg leading-tight tracking-tight font-sans">
                    <span className="text-transparent bg-clip-text bg-gradient-to-r from-aurora-purple to-aurora-green">SparkLog</span>
                </h1>
                <p className="text-[10px] text-slate-500 font-mono uppercase tracking-wider">AI Fragment Diary</p>
            </div>
            </div>
            <div className="flex gap-2">
                <button 
                    onClick={handleClearChat}
                    disabled={status !== 'idle' || messages.length <= 1}
                    className={`p-2.5 rounded-xl transition-all border border-transparent ${
                        status !== 'idle' || messages.length <= 1 
                        ? 'text-slate-300 cursor-not-allowed' 
                        : 'text-slate-400 hover:text-red-500 hover:bg-white hover:border-red-100 hover:shadow-sm'
                    }`}
                    title="æ¸…ç©ºå½“å‰å¯¹è¯"
                >
                    <Eraser size={20} />
                </button>
                <div className="w-px h-8 bg-slate-200 mx-1 self-center"></div>
                <button 
                    onClick={() => handleGenerateSummary(false)}
                    disabled={status !== 'idle'}
                    className={`p-2.5 rounded-xl transition-all border border-transparent ${
                        status !== 'idle' ? 'text-slate-300 cursor-not-allowed' : 'text-slate-500 hover:text-aurora-purple hover:bg-white hover:border-aurora-purple/20 hover:shadow-sm'
                    }`}
                    title="ç”Ÿæˆä»Šæ—¥æ—¥ç»“"
                >
                    <ScrollText size={20} />
                </button>
                <button 
                    onClick={() => setShowHistory(true)}
                    className="p-2.5 text-slate-500 hover:text-aurora-green hover:bg-white hover:border-aurora-green/20 border border-transparent rounded-xl transition-all hover:shadow-sm"
                    title="å†å²æ—¥è®°"
                >
                    <History size={20} />
                </button>
            </div>
        </div>
      </header>

      {/* Chat Area - Full Width Container for better scrolling */}
      <main className="flex-1 overflow-y-auto overflow-x-hidden w-full scroll-smooth">
        <div className="max-w-2xl mx-auto w-full px-4 py-6 space-y-2">
            {messages.map(msg => (
            <ChatMessage 
                key={msg.id} 
                message={msg} 
                onDelete={handleDeleteMessage}
            />
            ))}
            
            {status === 'thinking' && (
            <div className="flex items-center gap-2 text-slate-400 text-xs ml-5 mb-4 animate-pulse font-mono bg-white/40 inline-block px-3 py-1 rounded-full border border-white/50">
                <Sparkles size={12} className="text-aurora-purple" />
                <span>Thinking...</span>
            </div>
            )}
            
            {status === 'generating_summary' && (
            <div className="flex items-center gap-2 text-aurora-green text-xs ml-5 mb-4 animate-pulse font-mono bg-white/40 inline-block px-3 py-1 rounded-full border border-white/50">
                <ScrollText size={12} />
                <span>Generating Summary...</span>
            </div>
            )}

            <div ref={messagesEndRef} />
        </div>
      </main>

      {/* Input */}
      <InputArea onSendMessage={handleSendMessage} isLoading={status !== 'idle'} />

      {/* Summary Modal */}
      {showSummary && summaryData && (
        <DailySummary 
          data={summaryData} 
          onClose={() => setShowSummary(false)} 
        />
      )}

      {/* History Modal */}
      {showHistory && (
          <HistoryView 
            history={history}
            onSelect={handleHistorySelect}
            onDelete={handleDeleteHistory}
            onClose={() => setShowHistory(false)}
          />
      )}
    </div>
  );
}